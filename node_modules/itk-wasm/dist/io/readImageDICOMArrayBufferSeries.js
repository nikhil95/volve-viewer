var _a;
import createWebWorkerPromise from '../core/internal/createWebWorkerPromise.js';
import WorkerPool from '../core/WorkerPool.js';
import stackImages from '../core/stackImages.js';
import InterfaceTypes from '../core/InterfaceTypes.js';
import config from '../itkConfig.js';
const workerFunction = async (webWorker, fileDescriptions, singleSortedSeries = false) => {
    let worker = webWorker;
    const { webworkerPromise, worker: usedWorker } = await createWebWorkerPromise(worker);
    worker = usedWorker;
    const args = ['--memory-io', '--output-image', '0', '--output-filenames', '1', '--input-images'];
    fileDescriptions.forEach((desc) => {
        args.push(`./${desc.path}`);
    });
    if (singleSortedSeries) {
        args.push('--single-sorted-series');
    }
    const outputs = [
        { type: InterfaceTypes.Image },
        { type: InterfaceTypes.TextStream }
    ];
    const inputs = fileDescriptions.map((fd) => {
        return { type: InterfaceTypes.BinaryFile, data: fd };
    });
    const transferables = fileDescriptions.map(description => {
        return description.data.buffer;
    });
    const message = {
        operation: 'readDICOMImageSeries',
        config: config,
        fileDescriptions: fileDescriptions,
        singleSortedSeries,
        pipelinePath: 'ReadDICOMImageFileSeries',
        args,
        outputs,
        inputs
    };
    const result = await webworkerPromise.postMessage(message, transferables);
    const image = result.outputs[0].data;
    const filenames = result.outputs[1].data.data.split('\0');
    // remove the last element since we expect it to be empty
    filenames === null || filenames === void 0 ? void 0 : filenames.pop();
    if (image.metadata === undefined) {
        const metadata = {};
        metadata.orderedFileNames = filenames;
        image.metadata = metadata;
    }
    else {
        image.metadata.orderedFileNames = filenames;
    }
    return { image: result.outputs[0].data, webWorker: worker };
};
const numberOfWorkers = typeof ((_a = globalThis.navigator) === null || _a === void 0 ? void 0 : _a.hardwareConcurrency) === 'number' ? globalThis.navigator.hardwareConcurrency : 4;
const workerPool = new WorkerPool(numberOfWorkers, workerFunction);
const seriesBlockSize = 8;
const readImageDICOMArrayBufferSeries = async (arrayBuffers, singleSortedSeries = false, fileNames) => {
    const validFileNames = (fileNames != null) && fileNames.length === arrayBuffers.length;
    const fileDescriptions = arrayBuffers.map((ab, index) => {
        return { path: validFileNames ? fileNames[index] : `${index}.dcm`, data: new Uint8Array(ab) };
    });
    if (singleSortedSeries) {
        const taskArgsArray = [];
        for (let index = 0; index < fileDescriptions.length; index += seriesBlockSize) {
            const block = fileDescriptions.slice(index, index + seriesBlockSize);
            taskArgsArray.push([block, singleSortedSeries]);
        }
        const results = await workerPool.runTasks(taskArgsArray).promise;
        const images = results.map((result) => result.image);
        const stacked = stackImages(images);
        return { image: stacked, webWorkerPool: workerPool };
    }
    else {
        const taskArgsArray = [[fileDescriptions, singleSortedSeries]];
        const results = await workerPool.runTasks(taskArgsArray).promise;
        return { image: results[0].image, webWorkerPool: workerPool };
    }
};
export default readImageDICOMArrayBufferSeries;
//# sourceMappingURL=readImageDICOMArrayBufferSeries.js.map