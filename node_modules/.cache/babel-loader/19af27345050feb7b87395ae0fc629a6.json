{"ast":null,"code":"import \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport \"core-js/modules/es.string.match.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.string.includes.js\";\nimport \"core-js/modules/es.array.slice.js\";\n\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\nfunction getYOffsetFromTransform(matStr) {\n  if (!matStr || matStr === 'none') {\n    return 0;\n  }\n\n  var values = matStr.match(/matrix(?:3d)?\\((.+)\\)/)[1].split(',').map(function (v) {\n    return Number(v);\n  });\n  var is3D = matStr.includes('3d');\n  return is3D ? values[13] : values[5];\n}\n\nexport default {\n  props: {\n    slice: {\n      type: Number,\n      default: 0\n    },\n    min: {\n      type: Number,\n      required: true\n    },\n    max: {\n      type: Number,\n      required: true\n    },\n    step: {\n      type: Number,\n      required: true\n    },\n    handleHeight: {\n      type: Number,\n      default: 20\n    }\n  },\n  data: function data() {\n    return {\n      maxHandlePos: 0,\n      dragging: false,\n      initialHandlePos: 0,\n      initialMousePosY: 0,\n      yOffset: 0\n    };\n  },\n  computed: {\n    handlePosition: function handlePosition() {\n      var range = this.max - this.min <= 0 ? 1 : this.max - this.min;\n      var pos = this.maxHandlePos * ((this.slice - this.min) / range);\n      return this.dragging ? this.draggingHandlePos : pos;\n    },\n    draggingHandlePos: function draggingHandlePos() {\n      return Math.min(Math.max(0, this.initialHandlePos + this.yOffset), this.maxHandlePos);\n    }\n  },\n  mounted: function mounted() {\n    var _this = this;\n\n    this.updateMaxHandlePos();\n    this.resizeObserver = new ResizeObserver(function (entries) {\n      if (entries.length === 1) {\n        _this.updateMaxHandlePos();\n      }\n    });\n    this.resizeObserver.observe(this.$refs.handleContainer);\n  },\n  beforeDestroy: function beforeDestroy() {\n    this.resizeObserver.disconnect();\n  },\n  methods: {\n    updateMaxHandlePos: function updateMaxHandlePos() {\n      this.maxHandlePos = this.$refs.handleContainer.clientHeight - this.handleHeight;\n    },\n    onDragStart: function onDragStart(ev) {\n      ev.preventDefault();\n      this.dragging = true;\n      this.initialMousePosY = ev.pageY;\n\n      if (ev.target === this.$refs.handle) {\n        var handleStyles = window.getComputedStyle(this.$refs.handle);\n        this.initialHandlePos = getYOffsetFromTransform(handleStyles.transform);\n      } else {\n        // move handle to mouse pos\n        var _this$$refs$handleCon = this.$refs.handleContainer.getBoundingClientRect(),\n            y = _this$$refs$handleCon.y;\n\n        this.initialHandlePos = Math.max(0, Math.min(this.maxHandlePos, ev.pageY - y - this.handleHeight / 2));\n        var newSlice = this.getNearestSlice(this.initialHandlePos);\n        this.$emit('input', newSlice);\n      }\n\n      this.yOffset = 0;\n      document.addEventListener('mousemove', this.onDragMove);\n      document.addEventListener('mouseup', this.onDragEnd);\n    },\n    onDragMove: function onDragMove(ev) {\n      ev.preventDefault();\n      this.yOffset = ev.pageY - this.initialMousePosY;\n      var slice = this.getNearestSlice(this.handlePosition);\n      this.$emit('input', slice);\n    },\n    onDragEnd: function onDragEnd(ev) {\n      ev.preventDefault();\n      this.dragging = false;\n      document.removeEventListener('mousemove', this.onDragMove);\n      document.removeEventListener('mouseup', this.onDragEnd);\n      var slice = this.getNearestSlice(this.handlePosition);\n      this.$emit('input', slice);\n    },\n    getNearestSlice: function getNearestSlice(pos) {\n      var sliceEstimate = pos / this.maxHandlePos;\n      var frac = sliceEstimate * (this.max - this.min) + this.min;\n      return Math.round(frac / this.step) * this.step;\n    }\n  }\n};","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAeA;EACA;IACA;EACA;;EACA,oBACAA,KADA,CACA,uBADA,EACA,CADA,EAEAC,KAFA,CAEA,GAFA,EAGAC,GAHA,CAGA;IAAA;EAAA,CAHA;EAIA;EACA;AACA;;AAEA;EACAC;IACAC;MACAC,YADA;MAEAC;IAFA,CADA;IAKAC;MACAF,YADA;MAEAG;IAFA,CALA;IASAC;MACAJ,YADA;MAEAG;IAFA,CATA;IAaAE;MACAL,YADA;MAEAG;IAFA,CAbA;IAiBAG;MACAN,YADA;MAEAC;IAFA;EAjBA,CADA;EAwBAM,IAxBA,kBAwBA;IACA;MACAC,eADA;MAEAC,eAFA;MAGAC,mBAHA;MAIAC,mBAJA;MAKAC;IALA;EAOA,CAhCA;EAkCAC;IACAC,cADA,4BACA;MACA;MACA;MACA;IACA,CALA;IAMAC,iBANA,+BAMA;MACA,gBACAC,iDADA,EAEA,iBAFA;IAIA;EAXA,CAlCA;EAgDAC,OAhDA,qBAgDA;IAAA;;IACA;IACA;MACA;QACA;MACA;IACA,CAJA;IAKA;EACA,CAxDA;EA0DAC,aA1DA,2BA0DA;IACA;EACA,CA5DA;EA8DAC;IACAC,kBADA,gCACA;MACA,oBACA,2DADA;IAEA,CAJA;IAMAC,WANA,uBAMAC,EANA,EAMA;MACAA;MAEA;MACA;;MAEA;QACA;QACA;MACA,CAHA,MAGA;QACA;QACA;QAAA;;QACA,iCACA,CADA,EAEAN,iEAFA;QAIA;QACA;MACA;;MAEA;MAEAO;MACAA;IACA,CA9BA;IAgCAC,UAhCA,sBAgCAF,EAhCA,EAgCA;MACAA;MAEA;MACA;MACA;IACA,CAtCA;IAwCAG,SAxCA,qBAwCAH,EAxCA,EAwCA;MACAA;MAEA;MACAC;MACAA;MACA;MACA;IACA,CAhDA;IAkDAG,eAlDA,2BAkDAC,GAlDA,EAkDA;MACA;MACA;MACA;IACA;EAtDA;AA9DA","names":["match","split","map","props","slice","type","default","min","required","max","step","handleHeight","data","maxHandlePos","dragging","initialHandlePos","initialMousePosY","yOffset","computed","handlePosition","draggingHandlePos","Math","mounted","beforeDestroy","methods","updateMaxHandlePos","onDragStart","ev","document","onDragMove","onDragEnd","getNearestSlice","pos"],"sourceRoot":"src/components","sources":["SliceSlider.vue"],"sourcesContent":["<template>\n  <div class=\"slice-slider\" ref=\"handleContainer\" @mousedown=\"onDragStart\">\n    <div class=\"slice-slider-track\" />\n    <div\n      class=\"slice-slider-handle\"\n      ref=\"handle\"\n      :style=\"{\n        height: `${handleHeight}px`,\n        transform: `translate3d(0, ${handlePosition}px, 0)`,\n      }\"\n    />\n  </div>\n</template>\n\n<script>\nfunction getYOffsetFromTransform(matStr) {\n  if (!matStr || matStr === 'none') {\n    return 0;\n  }\n  const values = matStr\n    .match(/matrix(?:3d)?\\((.+)\\)/)[1]\n    .split(',')\n    .map((v) => Number(v));\n  const is3D = matStr.includes('3d');\n  return is3D ? values[13] : values[5];\n}\n\nexport default {\n  props: {\n    slice: {\n      type: Number,\n      default: 0,\n    },\n    min: {\n      type: Number,\n      required: true,\n    },\n    max: {\n      type: Number,\n      required: true,\n    },\n    step: {\n      type: Number,\n      required: true,\n    },\n    handleHeight: {\n      type: Number,\n      default: 20,\n    },\n  },\n\n  data() {\n    return {\n      maxHandlePos: 0,\n      dragging: false,\n      initialHandlePos: 0,\n      initialMousePosY: 0,\n      yOffset: 0,\n    };\n  },\n\n  computed: {\n    handlePosition() {\n      const range = this.max - this.min <= 0 ? 1 : this.max - this.min;\n      const pos = this.maxHandlePos * ((this.slice - this.min) / range);\n      return this.dragging ? this.draggingHandlePos : pos;\n    },\n    draggingHandlePos() {\n      return Math.min(\n        Math.max(0, this.initialHandlePos + this.yOffset),\n        this.maxHandlePos\n      );\n    },\n  },\n\n  mounted() {\n    this.updateMaxHandlePos();\n    this.resizeObserver = new ResizeObserver((entries) => {\n      if (entries.length === 1) {\n        this.updateMaxHandlePos();\n      }\n    });\n    this.resizeObserver.observe(this.$refs.handleContainer);\n  },\n\n  beforeDestroy() {\n    this.resizeObserver.disconnect();\n  },\n\n  methods: {\n    updateMaxHandlePos() {\n      this.maxHandlePos =\n        this.$refs.handleContainer.clientHeight - this.handleHeight;\n    },\n\n    onDragStart(ev) {\n      ev.preventDefault();\n\n      this.dragging = true;\n      this.initialMousePosY = ev.pageY;\n\n      if (ev.target === this.$refs.handle) {\n        const handleStyles = window.getComputedStyle(this.$refs.handle);\n        this.initialHandlePos = getYOffsetFromTransform(handleStyles.transform);\n      } else {\n        // move handle to mouse pos\n        const { y } = this.$refs.handleContainer.getBoundingClientRect();\n        this.initialHandlePos = Math.max(\n          0,\n          Math.min(this.maxHandlePos, ev.pageY - y - this.handleHeight / 2)\n        );\n        const newSlice = this.getNearestSlice(this.initialHandlePos);\n        this.$emit('input', newSlice);\n      }\n\n      this.yOffset = 0;\n\n      document.addEventListener('mousemove', this.onDragMove);\n      document.addEventListener('mouseup', this.onDragEnd);\n    },\n\n    onDragMove(ev) {\n      ev.preventDefault();\n\n      this.yOffset = ev.pageY - this.initialMousePosY;\n      const slice = this.getNearestSlice(this.handlePosition);\n      this.$emit('input', slice);\n    },\n\n    onDragEnd(ev) {\n      ev.preventDefault();\n\n      this.dragging = false;\n      document.removeEventListener('mousemove', this.onDragMove);\n      document.removeEventListener('mouseup', this.onDragEnd);\n      const slice = this.getNearestSlice(this.handlePosition);\n      this.$emit('input', slice);\n    },\n\n    getNearestSlice(pos) {\n      const sliceEstimate = pos / this.maxHandlePos;\n      const frac = sliceEstimate * (this.max - this.min) + this.min;\n      return Math.round(frac / this.step) * this.step;\n    },\n  },\n};\n</script>\n\n<style scoped>\n.slice-slider-handle {\n  position: relative;\n  width: 100%;\n  background: #ccc;\n  box-sizing: border-box;\n  border-radius: 3px;\n  border: 1px solid #999;\n}\n\n.slice-slider-track {\n  position: absolute;\n  margin: 0 auto;\n  top: 8px;\n  left: 0;\n  right: 0;\n  bottom: 8px;\n  width: 1px;\n  border: 1px solid #888;\n  border-radius: 2px;\n}\n</style>\n"]},"metadata":{},"sourceType":"module"}